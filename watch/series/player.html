<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Better Anime</title>
    <script src="https://vjs.zencdn.net/8.3.0/video.min.js"></script>
    <link rel="icon" type="image/x-icon" href="https://raw.githubusercontent.com/TheFarawayDev/better-anime/refs/heads/main/watch/other/BA.png">
    <link href="https://vjs.zencdn.net/8.3.0/video-js.css" rel="stylesheet">
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #121212;
            margin: 0;
            padding: 20px;
            font-family: sans-serif;
            color: #fff;
        }
        .artplayer-app-container {
            width: 80%;
            max-width: 800px;
            background: #121212;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .site-link-bar {
            width: 100%;
            background-color: #1e1e1e;
            padding: 10px;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            box-sizing: border-box;
            margin-bottom: 10px;
        }
        .site-link {
            font-weight: bold;
            color: #fff;
            text-decoration: none;
            font-size: 1.2em;
        }
        .player-header {
            width: 100%;
            text-align: center;
            padding: 10px 0;
            font-size: 1.5em;
            margin-bottom: 10px;
        }
        .artplayer-app {
            width: 100%;
            aspect-ratio: 16 / 9;
            background: black;
        }
        .controls-area {
            width: 100%;
            background-color: #1e1e1e;
            padding: 10px;
            display: flex;
            justify-content: center;
            gap: 10px;
            box-sizing: border-box;
            margin-top: 10px;
        }

        .episode-control-area {
            width: 100%;
            background-color: #1e1e1e;
            padding: 10px;
            display: flex;
            justify-content: center;
            gap: 10px;
            box-sizing: border-box;
            margin-top: 10px;
        }
        .episode-control-area button.active {
            background-color: #23ade5;
        }
        .controls-area button {
            width: 100%;
        }
        .controls-area button.active {
            background-color: #23ade5;
        }
        .episode-list-container {
            width: 80%;
            max-width: 800px;
            margin-top: 20px;
            background-color: #1e1e1e;
            padding: 15px;
            border-radius: 5px;
            box-sizing: border-box;
            overflow-y: auto;
            scrollbar-width: none; /* For Firefox */
            -ms-overflow-style: none; /* For Internet Explorer and Edge */
        }
        .episode-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 8px;
            width: 100%;
        }
        .episode-list-container::-webkit-scrollbar {
            display: none; /* For Chrome, Safari, and Opera */
        }
        .episode-list button {
            background-color: #333;
            color: #fff;
            border: none;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            border-radius: 5px;
            box-sizing: border-box;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 0.9em;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .episode-list button.active {
            background-color: #23ade5;
        }
        button {
            background-color: #333;
            color: #fff;
            border: none;
            padding: 8px 15px;
            cursor: pointer;
            border-radius: 3px;
        }
        button:hover {
            background-color: #555;
        }
        @media (max-width: 768px) {
            .episode-list-container {
                overflow-y: scroll;
                max-height: 300px;
            }
            .episode-list {
                display: block; /* Change to block for vertical scrolling */
            }
            .episode-list button {
                display: block;
                width: 100%;
                margin-bottom: 8px;
            }
        }

        @media (max-width: 768px) and (orientation: landscape) {
            .episode-list button {
                font-size: 0.8em; /* Adjust font size for landscape mode */
                padding: 8px; /* Adjust padding for consistency */
            }

            .controls-area button,
            .episode-control-area button {
                font-size: 0.9em; /* Ensure language options and navigation buttons are consistent */
            }
        }
    </style>
    <script>
        // Block developer tools
        (function() {
            const devtools = /./;
            devtools.toString = function() {
                this.opened = true;
                alert('Developer tools are blocked for security reasons.');
            };
            Object.defineProperty(window, 'devtools', {
                get: function() {
                    return devtools;
                }
            });
            setInterval(() => {
                if (devtools.opened) {
                    window.location.reload();
                }
            }, 1000);
        })();

        // Disable right-click, key combinations for dev tools, and "More Tools" options
        document.addEventListener('contextmenu', (e) => e.preventDefault());
        document.addEventListener('keydown', (e) => {
            if (
                e.ctrlKey && 
                (e.key === 'u' || e.key === 's' || e.key === 'i' || e.key === 'j' || e.key === 'c') || 
                (e.ctrlKey && e.shiftKey && e.key === 'I') // Block Ctrl+Shift+I
            ) {
                e.preventDefault();
                alert('This action is disabled for security reasons.');
            }
        });

        // Disable "More Tools" options in browsers
        const disableMoreTools = () => {
            const iframe = document.createElement('iframe');
            iframe.style.display = 'none';
            document.body.appendChild(iframe);
            iframe.contentWindow.eval(`
                Object.defineProperty(navigator, 'webdriver', { get: () => true });
            `);
            document.body.removeChild(iframe);
        };

        document.addEventListener('DOMContentLoaded', disableMoreTools);
    </script>
</head>
<body>
    <div class="artplayer-app-container">
        <div class="site-link-bar">
            <a href="https://thefarawaydev.github.io/better-anime/home" class="site-link">Better Anime</a>
        </div>
        <video id="videoPlayer" class="video-js vjs-default-skin" controls preload="auto" playsinline webkit-playsinline x-webkit-airplay="allow"></video>
        <div class="controls-area">
            <button id="subbedButton">Subbed</button>
            <button id="dubbedButton">Dubbed</button>
        </div>

        <div class="episode-control-area">
            <button id="previousButton" style="width: 100%;">◄◄</button>
            <button id="autoNextButton" style="width: 100%;">Auto Next</button>
            <button id="skipIntroButton" style="width: 100%;">Skip Intro</button>
            <button id="nextButton" style="width: 100%;">►►</button>
        </div>
    </div>

    <div class="episode-list-container">
        <div class="episode-list">
        </div>
    </div>

    <script>
        const videoPlayer = videojs('videoPlayer', videojs.obj.merge({
            autoplay: true,
            controls: true,
            preload: 'auto',
            fluid: true,
            techOrder: ['html5'], // Ensure video.js uses its built-in HLS
        }));

        const subbedButton = document.getElementById('subbedButton');
        const dubbedButton = document.getElementById('dubbedButton');
        const previousButton = document.getElementById('previousButton');
        const nextButton = document.getElementById('nextButton');
        const autoNextButton = document.getElementById('autoNextButton');
        const currentLanguageSpan = document.getElementById('currentLanguage');
        const episodeListContainer = document.querySelector('.episode-list');
        const apiUrlBase = 'https://better-anime.vercel.app';
        const proxyUrl = 'https://another-m3u8-proxy.onrender.com/m3u8-proxy?url=';
        const proxyHeaders = '&headers={"referer":"https://megacloud.club/"}';

        const urlParams = new URLSearchParams(window.location.search);
        const currentAnimeId = urlParams.get('id');
        let currentEpisodeId = null;
        let currentEpisodeTitle = null;
        let currentCategory = localStorage.getItem('preferredCategory') || 'sub';
        let hasSubbed = false;
        let hasDubbed = false;
        let episodesData = []; // Store the fetched episodes data
        let currentEpisodeIndex = 0;
        let autoNext = false; // Add autoNext state
        let videoEnded = false; //track ended
        let isPlaying = false; // Track if video is playing

        const skipIntroButton = document.getElementById('skipIntroButton');
        let introStart = null;
        let introEnd = null;
        let outroStart = null;
        let outroEnd = null;

        function playM3u8(video, url) {
            videoPlayer.src({
                src: url,
                type: 'application/x-mpegURL',
            });
            videoPlayer.ready(() => {
                video.play();
            });
        }

        function saveToContinueWatching(id) {
            let continueWatchingArray = JSON.parse(localStorage.getItem('continueWatching')) || [];
            const existingItemIndex = continueWatchingArray.findIndex(item => item.id === id);
            const pageUrl = window.location.href;

            if (existingItemIndex !== -1) {
                continueWatchingArray[existingItemIndex].url = pageUrl;
            } else {
                continueWatchingArray.push({ id, url: pageUrl });
            }

            localStorage.setItem('continueWatching', JSON.stringify(continueWatchingArray));
            saveAllData(); // Ensure all data is saved after updating continue watching
        }

        document.addEventListener('DOMContentLoaded', () => {
            if (currentAnimeId) {
                saveToContinueWatching(currentAnimeId);
            }
        });

        function initializeVideoPlayer(url) {
            videoPlayer.src({
                src: url,
                type: 'application/x-mpegURL', // Use video.js's built-in HLS support
            });

            videoPlayer.ready(() => {
                const savedTime = loadProgress(); // Load saved progress
                if (savedTime > 0) {
                    videoPlayer.currentTime(savedTime); // Resume from saved time
                }
                videoPlayer.play();
            });

            // Disable playback rate controls
            videoPlayer.controlBar.removeChild('playbackRateMenuButton');

            // Explicitly disable text tracks and hide CC button
            videoPlayer.textTracks().tracks_.forEach(track => {
                track.mode = 'disabled';
            });
            const ccButton = videoPlayer.controlBar.getChild('SubsCapsButton');
            if (ccButton) {
                videoPlayer.controlBar.removeChild(ccButton);
            }

            // Hide CC button on iOS and Android
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            if (isMobile) {
                const ccButtonMobile = videoPlayer.controlBar.getChild('SubsCapsButton');
                if (ccButtonMobile) {
                    ccButtonMobile.hide();
                }
            }

            videoPlayer.on('timeupdate', () => {
                if (currentEpisodeId && currentEpisodeTitle) {
                    saveProgress(videoPlayer.currentTime()); // Save only the current time
                }
                saveAllData(); // Save all data to the structured object
            });
        }

        async function fetchAnimeEpisodes(animeId) {
            try {
                const response = await fetch(`${apiUrlBase}/api/v2/hianime/anime/${animeId}/episodes`);
                const data = await response.json();
                if (data.success && data.data && data.data.episodes) {
                    episodesData = data.data.episodes;
                    displayEpisodes(episodesData);
                } else {
                    alert('Could not load episodes.');
                }
            } catch (error) {
                console.error('Error fetching episodes:', error);
                alert('Error loading episodes.');
            }
        }

        function displayEpisodes(episodes) {
            episodeListContainer.innerHTML = '';
            episodes.forEach((episode, index) => {
                const button = document.createElement('button');
                button.textContent = `Episode ${episode.number}: ${episode.title}`;
                button.dataset.url = episode.url;
                button.dataset.episodeId = episode.episodeId;
                button.dataset.episodeTitle = episode.title;
                button.style.transitionDelay = `${index * 50}ms`;
                button.style.opacity = 0;
                button.addEventListener('click', () => {
                    currentEpisodeIndex = index; // Update current episode index
                    highlightCurrentEpisode(button);
                    loadEpisodeServers(episode.episodeId, episode.title);
                });
                episodeListContainer.appendChild(button);
                requestAnimationFrame(() => {
                    button.style.opacity = 1;
                });
            });
        }

        function highlightCurrentEpisode(selectedButton) {
            document.querySelectorAll('.episode-list button').forEach(button => button.classList.remove('active'));
            selectedButton.classList.add('active');
        }

        async function loadEpisodeServers(episodeId, episodeTitle) {
            currentEpisodeId = episodeId;
            currentEpisodeTitle = episodeTitle;
            localStorage.setItem('lastWatchedEpisodeId_' + currentAnimeId, episodeId);
            localStorage.setItem('lastWatchedEpisodeTitle_' + currentAnimeId, episodeTitle);

            try {
                const response = await fetch(`${apiUrlBase}/api/v2/hianime/episode/sources?animeEpisodeId=${episodeId}&server=hd-2&category=${currentCategory}`);
                const data = await response.json();

                if (data.success && data.data) {
                    const { intro, outro, sources } = data.data;

                    // Set intro and outro times
                    introStart = intro?.start || null;
                    introEnd = intro?.end || null;
                    outroStart = outro?.start || null;
                    outroEnd = outro?.end || null;

                    if (sources.length > 0) {
                        const videoUrl = `${proxyUrl}${encodeURIComponent(sources[0].url)}`;
                        initializeVideoPlayer(videoUrl);
                    } else {
                        alert(`No ${currentCategory} streams found for this episode.`);
                    }
                } else {
                    alert('Could not load episode data.');
                }
            } catch (error) {
                console.error('Error loading episode servers:', error);
                alert('Error loading episode data.');
            }
        }

        async function fetchStreamingLinks(episodeId, category) {
            try {
                const response = await fetch(`${apiUrlBase}/api/v2/hianime/episode/sources?animeEpisodeId=${episodeId}&server=hd-2&category=${category}`);
                const data = await response.json();
                if (data.success && data.data && data.data.sources) {
                    return data.data.sources;
                }
                return [];
            } catch (error) {
                console.error(`Error fetching ${category} streaming links:`, error);
                return [];
            }
        }

        async function loadStreamingLinks(episodeId, category) {
            try {
                const sources = await fetchStreamingLinks(episodeId, category);
                if (sources.length > 0) {
                    const videoUrl = `${proxyUrl}${encodeURIComponent(sources[0].url)}`; // Removed proxyHeaders
                    initializeVideoPlayer(videoUrl);
                    currentLanguageSpan.textContent = category === 'sub' ? 'Subbed' : 'Dubbed';
                } else if (category === 'sub' && hasDubbed) {
                    currentCategory = 'dub';
                    localStorage.setItem('preferredCategory', currentCategory);
                    loadStreamingLinks(episodeId, 'dub');
                } else if (category === 'dub' && hasSubbed) {
                    currentCategory = 'sub';
                    localStorage.setItem('preferredCategory', currentCategory);
                    loadStreamingLinks(episodeId, 'sub');
                }
            } catch (error) {
                console.error(`Error loading ${category} stream:`, error);
            }
        }

        function saveProgress(currentTime) {
            if (!currentAnimeId || !currentEpisodeId || !currentEpisodeTitle) {
                return;
            }

            // Remove progress of the previous episode
            const progressKeys = Object.keys(localStorage).filter(key =>
                key.startsWith(`watchProgress_${currentAnimeId}_`) && !key.endsWith(`_${currentEpisodeId}`)
            );
            progressKeys.forEach(key => localStorage.removeItem(key));

            // Save progress for the current episode
            const progressKey = `watchProgress_${currentAnimeId}_${currentEpisodeId}`;
            const progressData = {
                lastTime: Math.round(currentTime), // Save rounded time
                title: currentEpisodeTitle,
                category: currentCategory
            };
            localStorage.setItem(progressKey, JSON.stringify(progressData));
            saveAllData(); // Ensure all data is saved after updating progress
        }

        function loadProgress() {
            if (!currentAnimeId || !currentEpisodeId) {
                return 0;
            }

            const progressKey = `watchProgress_${currentAnimeId}_${currentEpisodeId}`;
            const savedData = localStorage.getItem(progressKey);
            if (savedData) {
                const progressData = JSON.parse(savedData);
                return progressData.lastTime || 0; // Return the saved time
            }
            return 0;
        }

        function playNextEpisode() {
            if (episodesData && currentEpisodeIndex < episodesData.length - 1) {
                currentEpisodeIndex++;
                const nextEpisode = episodesData[currentEpisodeIndex];
                currentEpisodeId = nextEpisode.episodeId;
                currentEpisodeTitle = nextEpisode.title;
                const nextEpisodeButton = Array.from(document.querySelectorAll('.episode-list button'))[currentEpisodeIndex];

                if (nextEpisodeButton) {
                    highlightCurrentEpisode(nextEpisodeButton);
                    loadEpisodeServers(nextEpisode.episodeId, nextEpisode.title);
                    console.log("Playing next episode:", nextEpisode.title);
                } else {
                    console.log("next episode button not found");
                }
            } else {
                console.log("end of episodes");
            }
        }

        function playPreviousEpisode() {
            if (episodesData && currentEpisodeIndex > 0) {
                currentEpisodeIndex--;
                const previousEpisode = episodesData[currentEpisodeIndex];
                currentEpisodeId = previousEpisode.episodeId;
                currentEpisodeTitle = previousEpisode.title;
                const previousEpisodeButton = Array.from(document.querySelectorAll('.episode-list button'))[currentEpisodeIndex];
                if (previousEpisodeButton) {
                    highlightCurrentEpisode(previousEpisodeButton);
                    loadEpisodeServers(previousEpisode.episodeId, previousEpisode.title);
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            if (currentAnimeId) {
                // Load language preference before fetching episodes
                const preferredCategory = localStorage.getItem('preferredCategory') || 'sub';
                currentCategory = preferredCategory;

                // Set the preferred button as active
                if (currentCategory === 'sub') {
                    subbedButton.classList.add('active');
                    dubbedButton.classList.remove('active');
                } else if (currentCategory === 'dub') {
                    dubbedButton.classList.add('active');
                    subbedButton.classList.remove('active');
                }

                fetchAnimeEpisodes(currentAnimeId).then(() => {
                    const lastWatchedEpisodeId = localStorage.getItem('lastWatchedEpisodeId_' + currentAnimeId);
                    const lastWatchedEpisodeTitle = localStorage.getItem('lastWatchedEpisodeTitle_' + currentAnimeId);

                    if (lastWatchedEpisodeId && lastWatchedEpisodeTitle) {
                        const episodeButton = Array.from(document.querySelectorAll('.episode-list button')).find(
                            button => button.dataset.episodeId === lastWatchedEpisodeId
                        );

                        if (episodeButton) {
                            currentEpisodeIndex = Array.from(document.querySelectorAll('.episode-list button')).indexOf(episodeButton);
                            highlightCurrentEpisode(episodeButton);
                            loadEpisodeServers(lastWatchedEpisodeId, lastWatchedEpisodeTitle).then(() => {
                                if (hasSubbed || hasDubbed) {
                                    loadStreamingLinks(lastWatchedEpisodeId, currentCategory);
                                }
                            });
                        } else if (document.querySelector('.episode-list button:first-child')) {
                            document.querySelector('.episode-list button:first-child').click();
                        }
                    } else if (document.querySelector('.episode-list button:first-child')) {
                        document.querySelector('.episode-list button:first-child').click();
                    }
                });
            }

            // Restore autoNext state from local storage
            const savedAutoNext = localStorage.getItem('autoNext');
            if (savedAutoNext === 'true') {
                autoNext = true;
                autoNextButton.classList.add('active');
            }

            subbedButton.addEventListener('click', () => {
                if (currentEpisodeId && hasSubbed) {
                    currentCategory = 'sub';
                    localStorage.setItem('preferredCategory', currentCategory);
                    subbedButton.classList.add('active');
                    dubbedButton.classList.remove('active');
                    loadStreamingLinks(currentEpisodeId, currentCategory);
                }
            });

            dubbedButton.addEventListener('click', () => {
                if (currentEpisodeId && hasDubbed) {
                    currentCategory = 'dub';
                    localStorage.setItem('preferredCategory', currentCategory);
                    dubbedButton.classList.add('active');
                    subbedButton.classList.remove('active');
                    loadStreamingLinks(currentEpisodeId, currentCategory);
                }
            });

            autoNextButton.addEventListener('click', () => {
                autoNext = !autoNext;
                localStorage.setItem('autoNext', autoNext); // Save autoNext state to local storage
                autoNextButton.classList.toggle('active', autoNext);
            });
        });

        videoPlayer.on('ended', () => {
            videoEnded = true;
            if (autoNext) {
                playNextEpisode();
            }
        });

        // Skip intro and outro functionality
        videoPlayer.on('timeupdate', () => {
            const currentTime = videoPlayer.currentTime();

            // Skip intro
            if (introStart !== null && introEnd !== null && currentTime >= introStart && currentTime < introEnd && skipIntroButton.classList.contains('active')) {
                videoPlayer.currentTime(introEnd);
            }

            // Skip outro
            if (outroStart !== null && outroEnd !== null && currentTime >= outroStart && currentTime < outroEnd && skipIntroButton.classList.contains('active')) {
                videoPlayer.currentTime(outroEnd);
            }
        });

        // Toggle skip intro/outro button
        skipIntroButton.addEventListener('click', () => {
            skipIntroButton.classList.toggle('active');
            localStorage.setItem('skipIntro', skipIntroButton.classList.contains('active')); // Save skip intro state
            saveAllData(); // Save the updated skip intro state
        });

        // Save all data to a single structured object in localStorage
        function saveAllData() {
            const allData = JSON.parse(localStorage.getItem('betterAnimeData')) || {};

            // Save only user preferences
            allData.skipIntro = skipIntroButton.classList.contains('active');
            allData.autoNext = autoNext;

            localStorage.setItem('betterAnimeData', JSON.stringify(allData));
        }

        // Load all data on page load
        function loadAllData() {
            const allData = JSON.parse(localStorage.getItem('betterAnimeData')) || {};

            // Restore user preferences
            if (allData.skipIntro !== undefined) {
                skipIntroButton.classList.toggle('active', allData.skipIntro);
            }
            if (allData.autoNext !== undefined) {
                autoNext = allData.autoNext;
                autoNextButton.classList.toggle('active', autoNext);
            }
        }

        // Load all data on page load
        document.addEventListener('DOMContentLoaded', () => {
            loadAllData();
            if (currentAnimeId) {
                saveToContinueWatching(currentAnimeId);
            }

            // Restore autoNext state from local storage
            const savedAutoNext = localStorage.getItem('autoNext');
            autoNext = savedAutoNext === 'true';
            autoNextButton.classList.toggle('active', autoNext);

            // Restore skipIntro state from local storage
            const savedSkipIntro = localStorage.getItem('skipIntro');
            skipIntroButton.classList.toggle('active', savedSkipIntro === 'true');
        });

        // Event listeners for navigation buttons
        previousButton.addEventListener('click', playPreviousEpisode);
        nextButton.addEventListener('click', playNextEpisode);
        autoNextButton.addEventListener('click', () => {
            autoNext = !autoNext;
            localStorage.setItem('autoNext', autoNext);
            autoNextButton.classList.toggle('active', autoNext);
        });

    </script>
</body>
</html>
